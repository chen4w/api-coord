---
title: HTTP多次同步请求
date: 2021-10-25 14:28:35
permalink: /pages/8c966d/
---

# 多次同步请求

!!! tip "提示"

    推荐使用[接入中间件](/mid/)进行接口存证，可大大减少用户代码量。



## 一、概述

> 当数据量过大，一次请求无法获取全部所需数据时，需要多次请求服务方接口。
>
> 此类情况每一次请求都需要进行一次[存证](/pages/0ebad0/#二、存证过程-概要)。

## 二、请求步骤

### 请求方

> 与单次请求存证过程相似，每一次请求都需要执行[单次请求](/pages/feba98/#请求方)的执行步骤。

!!! warning "注意"

    与[单次请求](/pages/feba98/#请求方)不同的是，每一次请求都需要对存证 [Header](/pages/76b411/#header) 对象的序号（seq）进行递增。

    同时，当当前请求为本次请求的最后一次时，需要将 [Header](/pages/76b411/#header) 对象中的结束标志（b_end），更改为 `true`。



### 服务方

> 服务方步骤，与HTTP单次同步服务方步骤相同。
>
> 可查看点击[此处](/pages/feba98/#服务方)进行查看。

## 三、代码示例

### 请求方

1. 封装的存证方法

    ```java linenums="1"
    /**
    * @return void
    * @description // 请求数据
    * @date 5:38 下午 2021/10/18
    * @params [paramMap (请求入参), cid（请求id）, req (请求序号，从1开始递增), isEnd（是否为最后一次请求）]
    **/
    public static void request(Map<String, Object> paramMap, String cid, int req, boolean isEnd) {
       // 获取yml文件中的信息
       RepchainConfig repchainConfig = YamlUtils.repchainConfig;
       List<InterCo> interCoList = repchainConfig.getRepchain().getInterCo();
       InterCo interCo = interCoList.get(0);
       List<Service> services = interCo.getServices();
       Service service = services.get(0);
       // 对业务请求数据进行hash取值
       String contentHash = DigestUtil.sha256Hex(JSONUtil.toJsonStr(paramMap));
       // 使用yml文件中的公钥和证书，对业务请求参数进行数据签名
       Signature signature = getSignature(interCo, contentHash);
       // 此处需要将构建的请求头内容传给服务方，此处请求头信息包含了接口协同需要存证的信息，及数据签名需要校验的身份信息
       Header header = customHeader(service, cid, isEnd, signature, req);
       paramMap.put("header", JSONUtil.toJsonStr(header));
       // 请求业务接口，服务方接口地址及端口号可从dashboard管理平台获取，然后将端口号和地址写入到yml文件中
       String result = HttpUtil.get("http://" + service.getTo_host() + ":" + service.getTo_port() + "/infoList", paramMap);
       System.out.println(result);
       // 获取返回结果对象
       InterCoResult resultMap = JSONUtil.toBean(result, InterCoResult.class);
       // 获取服务提供方签名信息
       Signature responseSignature = resultMap.getSignature();
       // 构建证书对象，用于签名数据及校验权限用
       SysCert sysCert = PkUtil.getSysCert(interCo);
       // 获取yml文件中配置的区块链的host地址
       String host = repchainConfig.getRepchain().getHost();
       // 创建请求实例，若用Spring 此处可以创建javabean
       RequestAck requestAck = new RequestAck(host);
       // 构建存证交易对象，使用证书和私钥对存证信息进行数据签名，提交给区块链进行存证
       ReqAckProof rb = getReqAckProof(header, contentHash, signature, responseSignature);
       JSONObject jsonObject = requestAck.rb(rb, sysCert);
       // 若果有错误信息，则提交存证数据失败
       if (!StrUtil.isBlankIfStr(jsonObject.get("err"))) {
           System.out.println("提交区块链数据失败：" + jsonObject);
       }
    }
    ```

2. 多次同步请求

    ```java linenums="1"
    // 生成本次请求的存证id，此id会在本次请求存证中重复使用
    String cid = SnowIdGenerator.getId();
    // 第一次调用
    // 构建接口调用参数
    Map<String, Object> paramMap = new HashMap<>(3);
    paramMap.put("pageSize", 1);
    paramMap.put("pageNo", 1);
    request(paramMap, cid, 1, false);
    // 第二次调用
    // 构建接口调用参数
    paramMap = new HashMap<>(3);
    paramMap.put("pageSize", 1);
    paramMap.put("pageNo", 2);
    request(paramMap, cid, 2, false);
    // 第三次调用
    // 构建接口调用参数
    paramMap = new HashMap<>(3);
    paramMap.put("pageSize", 1);
    paramMap.put("pageNo", 3);
    request(paramMap, cid, 3, false);
    // 第四次调用，注意此时为最后一次调用，需要将结束标志改为true
    // 构建接口调用参数
    paramMap = new HashMap<>(3);
     paramMap.put("pageSize", 1);
    paramMap.put("pageNo", 4);
    request(paramMap, cid, 4, true);
    ```

!!! tip "提示"

    完整代码可在代码示例中`repchain.inter.cooperation.http.sync.multi.request`查看或点击 [***此处***](https://gitee.com/BTAJL/api-coord/blob/http-lhc/src/main/java/repchain/inter/cooperation/http/sync/multi/request/MultiSyncClient.java) 在线查看。



### 服务方

> 服务方代码与HTTP单次请求方法逻辑相似。

1. 获取请求参数及存证请求头信息

    > 此处获取的header为存证的请求头，示例中将请求头放到request的parameter中传递到服务端。

    ```java linenums="1"
    // 获取调用方请求头header信息
    String headerStr = request.getParam("header");
    Header header = JSONUtil.toBean(headerStr, Header.class);
    // 获取业务请求数据
    int pageNo = Integer.parseInt(request.getParam("pageNo"));
    int pageSize = Integer.parseInt(request.getParam("pageSize"));
    ```

2. [数据验签](/pages/e84ef5/#数据验签)判断权限

    ```java linenums="1"
    // 2.校验请求方权限，校验请求方数据签名
    if (validAuth( header)) {
     // 编写业务代码及后续代码
    }else{
     // 返回结果没有权限
    }
    ```

3. 执行业务操作获取返回数据

    > 此处请根据实际业务进行业务代码的编写，文档中暂时不做代码示例。

4. 对返回数据进行[数据签名](/pages/e84ef5/#数据签名)

    ```java linenums="1"
    // 返回业务数据的数据结果
    List<Map<Object, Object>> resultList = new ArrayList<>();
    // 构建返回结果数据
    InterCoResult result = result
           .toBuilder()
           // 状态码
           .code(0)
           // 状态信息
           .msg("success")
           // 返回数据
           .data(resultList)
           // 签名数据
           .signature(sign(resultList))
           .build();
    ```

5. 返回数据及签名信息给请求方

    ```java linenums="1"
    return result;
    ```

   

!!! tip "提示"

    完整代码可在代码示例中`repchian.inter.cooperation.http.sync.multi.response`查看或点击 [***此处***](https://gitee.com/BTAJL/api-coord/blob/http-lhc/src/main/java/repchain/inter/cooperation/http/sync/multi/response/MultiSyncServer.java) 在线查看。


