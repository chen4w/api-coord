---
title: HTTP单次异步请求
date: 2021-10-26 08:59:22
permalink: /pages/7c927c/
---

## 一、概述

!!! tip "提示"

    推荐使用[接入中间件](/mid/)进行接口存证，可大大减少用户代码量。



> 异步请求，当调用服务方数据时，服务方需要有流程审批等原因，无法同步返回数据。此类情况需要在接口定义时，定义应答方接口规范，并让调用方进行接口实现。
>
> 此类情况则只完成两次[存证过程](/pages/0ebad0/#二、存证过程-概要)，调用方请求时需要存证，服务方应答调用方接口时同样也需要进行存证。

## 二、请求步骤

### **请求方**

> 由于是异步请求，请求方需要发送请求，并提供应答方调用接口，用于接收应答数据。

请求：

> 1. 构建请求数据
> 2. 对数据进行[数据签名](/pages/e84ef5/#数据签名)
> 3. 构建存证请求头
> 4. 发送请求数据到服务端，并接收返回结果
> 5. 构建[交易对象](/pages/e84ef5/#交易对象)
> 6. 提交给RepChain区块链

接收应答：

> 1. 获取请求参数及请求头信息
> 2. [数据验签](/pages/e84ef5/#数据验签)判断权限
> 3. 执行业务操作并构建返回数据结果
> 4. 对返回数据进行[数据签名](/pages/e84ef5/#数据签名)
> 5. 返回数据及签名信息给请求方

### **服务方**

接收请求：

> 1. 获取请求参数及请求头信息
> 2. [数据验签](/pages/e84ef5/#数据验签)判断权限
> 3. 将Header对象进行暂存，并构建已经收到请求的返回数据
> 4. 对返回数据进行[数据签名](/pages/e84ef5/#数据签名)
> 5. 返回数据及签名信息给请求方

应答调用方：

> 1. 从暂存数据中过去调用方发送的Header
> 2. 构建返回结果数据
> 3. 对数据进行[数据签名](/pages/e84ef5/#数据签名)
> 4. 构建存证请求头
> 5. 发送请求数据到应答接口，并接收返回结果
> 6. 构建[交易对象](/pages/e84ef5/#交易对象)
> 7. 提交给RepChain区块链

## 三、代码示例

### **请求方**

请求：

1. 调用请求方法进行单次请求

    ```java linenums="1"
    // 生成本次请求的存证id，此id会在本次请求存证中重复使用
    String cid = SnowIdGenerator.getId();
    // 构建接口调用参数
    Map<String, Object> paramMap = new HashMap<>(3);
    paramMap.put("name", "Tom");
    // 调用请求方法
    request(paramMap, cid);
    ```

2. 请求方法

    ```java linenums="1"
    /**
    * @description // 请求数据
    * @date 5:38 下午 2021/10/18
    * @params [paramMap (请求入参), cid（请求id）, req (请求序号，从1开始递增)]
    * @return void
    **/
    public static void request(Map<String, Object> paramMap, String cid) {
       // 获取yml文件中的信息
       RepchainConfig repchainConfig = YamlUtils.repchainConfig;
       List<InterCo> interCoList = repchainConfig.getRepchain().getInterCo();
       InterCo interCo = interCoList.get(0);
       List<Service> services = interCo.getServices();
       Service service = services.get(0);
       // 对业务请求数据进行hash取值
       String contentHash = DigestUtil.sha256Hex(JSONUtil.toJsonStr(paramMap));
       // 使用yml文件中的公钥和证书，对业务请求参数进行数据签名
       Signature signature = getSignature(interCo, contentHash);
       // 此处需要将构建的请求头内容传给服务方，此处请求头信息包含了接口协同需要存证的信息，及数据签名需要校验的身份信息
       Header header = customHeader(service, cid, false, signature, 1);
       paramMap.put("header", JSONUtil.toJsonStr(header));
       // 请求业务接口，服务方接口地址及端口号可从dashboard管理平台获取，然后将端口号和地址写入到yml文件中
       String result = HttpUtil.get("http://" + service.getTo_host() + ":" + service.getTo_port() + "/info", paramMap);
       System.out.println(result);
       // 获取返回结果对象
       InterCoResult resultMap = JSONUtil.toBean(result, InterCoResult.class);
       // 获取服务提供方签名信息
       Signature responseSignature = resultMap.getSignature();
       // 构建证书对象，用于签名数据及校验权限用
       SysCert sysCert = PkUtil.getSysCert(interCo);
       // 获取yml文件中配置的区块链的host地址
       String host = repchainConfig.getRepchain().getHost();
       // 创建请求实例，若用Spring 此处可以创建javabean
       RequestAck requestAck = new RequestAck(host);
       // 构建存证交易对象，使用证书和私钥对存证信息进行数据签名，提交给区块链进行存证
       ReqAckProof rb = getReqAckProof(header, contentHash, signature, responseSignature);
       JSONObject jsonObject = requestAck.rb(rb, sysCert);
       // 若果有错误信息，则提交存证数据失败
       if (!StrUtil.isBlankIfStr(jsonObject.get("err"))) {
           System.out.println("提交区块链数据失败：" + jsonObject);
       }
    }
    ```

!!! tip "提示"

    完整代码可在代码示例中`repchian.inter.cooperation.http.async.single.request.AsyncClient`查看或点击 [***此处***](https://gitee.com/BTAJL/api-coord/blob/http-lhc/src/main/java/repchain/inter/cooperation/http/async/single/request/AsyncClient.java) 在线查看。



接收应答

1. 获取应答参数及存证请求头信息

    > 此处获取的header为存证的请求头，示例中将请求头放到request的parameter中传递到应答接口的服务端。

    ```java linenums="1"
    // 获取调用方请求头header信息
    String headerStr = request.getParam("header");
    Header header = JSONUtil.toBean(headerStr, Header.class);
    ```
   
2. [数据验签](/pages/e84ef5/#数据验签)判断权限

    ```java linenums="1"
    // 2.校验请求方权限，校验请求方数据签名
    if (validAuth( header)) {
     // 获取请求返回的数据
     String data = request.getParam("data");
     // 编写业务代码
    }else{
     // 返回结果没有权限
    }
    ```

3. 执行业务操作获取返回数据

    > 此处请根据实际业务进行业务代码的编写，文档中暂时不做代码示例。

4. 对返回数据进行[数据签名](/pages/e84ef5/#数据签名)

    ```java linenums="1"
    // 构建返回结果数据
    InterCoResult result = result
                           .toBuilder()
                            // 状态码
                           .code(0)
                            // 状态信息
                           .msg("已收到返回数据")
                            // 签名数据
                           .signature(sign("已收到返回数据"))
                           .build();
    ```
   
5. 返回数据及签名信息给请求方

    ```java linenums="1"
    return result;
    ```

!!! tip "提示"

    完整代码可在代码示例中`repchian.inter.cooperation.http.async.single.request.AsyncRequestServer`查看或点击 [***此处***](https://gitee.com/BTAJL/api-coord/blob/http-lhc/src/main/java/repchain/inter/cooperation/http/async/single/request/AsyncRequestServer.java) 在线查看。


### **服务方**

接收请求：

1. 获取请求参数及存证请求头信息

    > 此处获取的header为存证的请求头，示例中将请求头放到request的parameter中传递到服务端。

    ```java linenums="1"
    // 获取调用方请求头header信息
    String headerStr = request.getParam("header");
    Header header = JSONUtil.toBean(headerStr, Header.class);
    // 获取业务请求数据
    String name = request.getParam("name");
    ```

2. [数据验签](/pages/e84ef5/#数据验签)判断权限，并执行业务代码示例，具体操作请根据自身业务代码进行更改

    ```java linenums="1"
    InterCoResult result = new InterCoResult();
    // 判断是否拥有访问权限
    if (validAuth(header)) {
       // 获取业务数据，将业务数据存入header并持久化到数据库
       String name = request.getParam("name");
       header.setData(JSONUtil.toJsonStr(name));
       // 将header信息存入数据库或其他持久化地方，方便异步返回数据时调用
       Db.use().insert(Entity.create("header").parseBean(header,true,true));
       // 构建返回结果，并对返回数据进行签名
       result = result
               .toBuilder()
               .code(0)
               .msg("数据已收到，待审核通过后返回请求数据！")
               .signature(sign("数据已收到，待审核通过后返回请求数据！"))
               .build();
    } else {
       // 3.构建失败返回结果数据
       result = result
               .toBuilder()
                // 状态码
               .code(1)
                // 状态信息
               .msg("no auth")
                // 签名数据
               .signature(sign("no auth"))
               .build();
    }
    ```

3. 返回数据及签名信息给请求方

    ```java linenums="1"
    return result;
    ```

!!! tip "提示"

    完整代码可在代码示例中`repchian.inter.cooperation.http.async.single.respones.AsyncServer`查看或点击 [***此处***](https://gitee.com/BTAJL/api-coord/blob/http-lhc/src/main/java/repchain/inter/cooperation/http/async/single/response/AsyncServer.java) 在线查看



应答调用方接口：

1. 获取暂存的Header

    ```java linenums="1"
    // 从数据库取出，之前请求方发送的数据及请求头，state=0 代表还没有返回的记录
    List<Entity> headers = Db.use().findAll(Entity.create("header").set("state", 0));
    ```

2. 根据Header执行[应答调用方](/pages/7c927c/#服务方)步骤

    ```java linenums="1"
    // 获取还未返回数据的header信息
    Header header = entity.toBean(Header.class);
    // 获取持久化的请求的业务数据
    String name = header.getData();
    // 业务逻辑获取返回结果数据
      .....
    Map<Object, Object> info = new HashMap<>(1);
    // 构建请求参数对象
    Map<String, Object> requestMap = new HashMap<>(1);
    requestMap.put("data", info);
    // 发送请求，并存证
    request(requestMap, header);
    ```

3. 封装的返回结果及存证方法

    ```java linenums="1"
    /**
    * @return void
    * @description // 请求数据
    * @date 5:38 下午 2021/10/18
    * @params [paramMap (请求入参),  dataHeader（暂存的请求方的Header）]
    **/
    public static void request(Map<String, Object> paramMap, Header dataHeader) {
       // 获取yml文件中的信息
       RepchainConfig repchainConfig = YamlUtils.repchainConfig;
       List<InterCo> interCoList = repchainConfig.getRepchain().getInterCo();
       InterCo interCo = interCoList.get(0);
       List<Service> services = interCo.getServices();
       Service service = services.get(0);
       // 对业务请求数据进行hash取值
       String contentHash = DigestUtil.sha256Hex(JSONUtil.toJsonStr(paramMap));
       // 使用yml文件中的公钥和证书，对业务请求参数进行数据签名
       Signature signature = getSignature(interCo, contentHash);
       // 此处需要将构建的请求头内容传给服务方，此处请求头信息包含了接口协同需要存证的信息，及数据签名需要校验的身份信息
       Header header = customHeader(service, true, signature, dataHeader);
       paramMap.put("header", JSONUtil.toJsonStr(header));
       String result;
       // 请求业务接口，服务方接口地址及端口号可从dashboard管理平台获取，然后将端口号和地址写入到yml文件中
       if ("GET".equals(dataHeader.getCallback_method())) {
           result = HttpUtil.get(dataHeader.getCallback_url(), paramMap);
       } else {
           result = HttpUtil.post(dataHeader.getCallback_url(), paramMap);
       }
       System.out.println(result);
       // 获取返回结果对象
       InterCoResult resultMap = JSONUtil.toBean(result, InterCoResult.class);
       // 获取服务提供方签名信息
       Signature responseSignature = resultMap.getSignature();
       // 构建证书对象，用于签名数据及校验权限用
       SysCert sysCert = PkUtil.getSysCert(interCo);
       // 获取yml文件中配置的区块链的host地址
       String host = repchainConfig.getRepchain().getHost();
       // 创建请求实例，若用Spring 此处可以创建javabean
       RequestAck requestAck = new RequestAck(host);
       // 构建存证交易对象，使用证书和私钥对存证信息进行数据签名，提交给区块链进行存证
       ReqAckProof rb = getReqAckProof(header, contentHash, signature, responseSignature);
       JSONObject jsonObject = requestAck.rb(rb, sysCert);
       // 若果有错误信息，则提交存证数据失败
       if (!StrUtil.isBlankIfStr(jsonObject.get("err"))) {
           System.out.println("提交区块链数据失败：" + jsonObject);
       }
    }
    ```

!!! tip "提示"

    完整代码可在代码示例中`repchian.inter.cooperation.http.async.single.respones.AsyncResponseClient`查看或点击 [***此处***](https://gitee.com/BTAJL/api-coord/blob/http-lhc/src/main/java/repchain/inter/cooperation/http/async/single/response/AsyncResponseClient.java) 在线查看。


